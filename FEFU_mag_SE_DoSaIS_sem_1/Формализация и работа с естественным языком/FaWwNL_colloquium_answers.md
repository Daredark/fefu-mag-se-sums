___

&nbsp;

# Ответы на вопросы коллоквиума по дисциплине "Формализация и работа с естественным языком"

&nbsp;

___

&nbsp;

## __Содержание__

&nbsp;

1.
2.
3. [Тема 1. Вопрос 3. Классификация грамматик по Хомскому (около 2115 символов) (pra3: 28-30)](#тема-1-вопрос-3-классификация-грамматик-по-хомскому-около-2115-символов-pra3-28-30)
4.
5. [Тема 1. Вопрос 5. Конечный автомат (около 1627 символов) (pra4: 37-39)](#тема-1-вопрос-5-конечный-автомат-около-1627-символов-pra4-37-39)
6. [Тема 1. Вопрос 6. Представление автоматов (около 1592 символов) (pra4: 41-42)](#тема-1-вопрос-6-представление-автоматов-около-1592-символов-pra4-41-42)
7.
8.
9. [Тема 2. Вопрос 9. В настоящем варианте модель «Смысл <=> Текст» предполагает пять основных уровней представления. (около 1404 символов) (pra5: 13-16)](#тема-2-вопрос-9-в-настоящем-варианте-модель-«смысл--текст»-предполагает-пять-основных-уровней-представления-около-1404-символов-pra5-13-16)
10.
11. [Тема 2. Вопрос 11. Толково-комбинаторный словарь (ТКС). Словарная статья такого словаря. (около 1470 символов) (pra5: 21-22)](#тема-2-вопрос-11-толково-комбинаторный-словарь-ткс-словарная-статья-такого-словаря-около-1470-символов-pra5-21-22)
12.
13.
14.
15. [Тема 3. Вопрос 15. Функциональная природа языка. (около 492 символов) (pra8: 24-27)](#тема-3-вопрос-15-функциональная-природа-языка-около-492-символов-pra8-24-27)
16.
17.
18.
19.
20. [Тема 3. Вопрос 20. Сущность семантического анализа. (около 149 символов) (pra10: 91) (доступна лишь часть ответа)](#тема-3-вопрос-20-сущность-семантического-анализа-около-149-символов-pra10-91-доступна-лишь-часть-ответа)

&nbsp;

___

&nbsp;

## __Пометки__

&nbsp;

1. 12652 chars (incompleted, leave it until the end) (WAY WAY WAY TOO FUCKED UP)
2. 3170 chars (completed, normalize length) (weak)
3. __2115 chars (Crazy & Ready)__
4. 3032 chars (completed, normalize length) (weak)
5. __1627 chars (Crazy & Ready)__
6. __1592 chars (Crazy & Ready)__
7. 2497 chars (completed, normalize length) (weak)
8. 2830 chars (completed, normalize length) (weak)
9. __1404 chars (Crazy & Ready)__
10. 2141 chars (completed, normalize length) (almost strong)
11. __1470 chars (Crazy & Ready)__
12. 2604 chars (completed, normalize length) (weak)
13. 3907 chars (completed, normalize length) (very weak)
14. 6222 chars (completed, normalize length) (weak)
15. __492 chars (Crazy & Ready)__
16. 4003 chars (completed, normalize length) (way too weak)
17. 5389 chars (completed, normalize length) (way too weak)
18. 2967 chars (completed, normalize length) (weak) (only a part of the answer is available)
19. 1578 chars (completed, normalize length) (almost strong)
20. __149 chars (Crazy & Ready) (only a part of the answer is available)__
&nbsp;

___

&nbsp;

## __1. Формальные грамматики и языки (WIP - overall last check) (12652 chars) (Topic 1: pra1: 2. -> 12.; pra2: 13. -> 20.; pra3: 21. -> 22.)__

&nbsp;

__2. Формальные грамматики__

- _Формальные грамматики - это системы правил, которые математически строго
задают (или характеризуют) множества цепочек, т.е.
конечных последовательностей символов._

Цепочки могут состоять из языковых элементов разных уровней: например,
- словоформы - это цепочки морфем,
- словосочетания и предложения - это цепочки слов.

Поэтому мы можем сказать, что формальные грамматики имеют дело с
абстрактными объектами.

__3. Классы формальных грамматик__

|_распознающие_|_порождающие_|
|-|-|
|т.е. такие, которые могут определять правильность цепочек.  В тех случаях, когда цепочки признаются грамматически правильными, грамматика может дать информацию о строении этой цепочки.|т.е. такие, которые могут строить правильные цепочки, давать информацию о грамматических характеристиках этих цепочек, а так же избегать порождения неграмматичных цепочек.|

И в распознающих, и в порождающих грамматиках все утверждения
формулируются в четко определенных символах с применением строго
определенных правил.
Это делает формальные грамматики очень простыми с точки зрения их
логического строения.

__4. Формальные грамматики и языки__

- Можно формально определить язык как подмножество множества всех
предложений из "слов" или символов некоторого основного словаря.
- _Алфавит_ - это непустое множество элементов.
Назовем элементы алфавита _символами_ (алфавит не обязан быть
конечным или счётным, но во всех практических приложениях он будет
конечным, может счётным).
- Всякая конечная последовательность символов алфавита $A$ называется
_цепочкой_.

___5. Формальные грамматики и языки (часть 2)__

Вот несколько цепочек в алфавите
$A = \{a, b, c\}\colon  a, \; b, \; c, \; ab,  \; aabb$.
Мы также допускаем существование пустой цепочки $\lambda{(e)}$, т.е.
цепочки не содержащей ни одного слова. Порядок символов в цепочке
важен.

Так цепочка $\textbf{аб}$, не то же самое, что и $\textbf{ба}$.
Длина цепочки $x$ - $|x|$ - равна числу символов в цепочке.:
$|\lambda| = 0, \; |a| = 1, \; |abc| = 3$.

Будем использовать буквы $a$, $b$, $c$, как имена символов алфавита,
в то время как $x$, $y$, $z$, $w$ - для обозначения цепочек символов.

Если $x$ и $y$ - цепочки, то их _конкатенация_ $xy$ является цепочкой,
полученная путём дописывания символов цепочки $y$ вслед за символами
цепочки $x$. Если $x=de$ и $y=ec$, то $xy=deec$.

__6. Формальные грамматики и языки (часть 3)__

Т.к. пустая цепочка $\lambda$ не содержит символов, то
$\lambda x = x \; \lambda = x$.

Если $z=xy$ - цепочка, то $x$ голова, а $y$ - хвост $z$.
И, наконец, $x$ - правильная голова, если $y$ - непустая цепочка
(не $\lambda$), $y$ - правильный хвост, если $x$ - не $\lambda$.

Если $x=\textbf{абс}$, то $\lambda$, $\textbf{а}$, $\textbf{аб}$,
$\textbf{абс}$ - голова, все правильные, кроме $\textbf{абс}$.
(Будем обозначать множество цепочек заглавными буквами).

- Произведение $AB$ двух множеств цепочек $A$, и $B$ определяется
как $AB = \{xy| \; x \; A,y \; B\}$.
Пусть $A=\{a,b\}$ и $B=\{c,d\}$, то $AB = \{ac, ad, bc, bd\}$

Т.к. $\lambda x = x \; \lambda = x$ для любой цепочки, то
$\{\lambda\} A = A \{\lambda\} = A$ (множество из пустых цепочек можно
и слева, и справа домножать).

__7. Формальные грамматики и языки (часть 4)__

Определим степень цепочки:
- $x^0$ - пустая цепочка $\lambda$
- $x^1 = x$
- $x^2 = xx$
- $x^3 = xxx$
- $\ldots$
- $x^n = xx^{n-1} = x^{n-1}x \;\;\;\;\;\;\; (n>0)$

Аналогично определяется степень алфавита $A$:
$$A^0 = \{\lambda\}, \; A^1 = 1, \ldots, A^n=AA^{n-1}=A^{n-1}A, \quad n>0$$

Определим 2 операции:
- Итерацию $A^*$ множества $A$: $\;\;\;$ $A^* = A^0 A^+$
и усечённую итерацию $A^+$ множества
$A$: $\;\;$ $A^+ = A^1 A^2 \ldots A^n \ldots$
- Таким образом, если $A=\{a,b\}$, то $A^*$ включает цепочки $\lambda$,
$\textbf{а}$, $\textbf{б}$, $\textbf{аа}$, $\textbf{аб}$, $\textbf{ба}$
$\textbf{ааа}$, $\textbf{ааб}$, $\textbf{бб}$, $\ldots$
- $A^+ = A A^* = A^* A$

__8. Определение 1__

- _Продукцией_ или _правилами_ подстановки называется упорядоченная пара
$(u,x)$, которая записывается так $u\text{::}\!\!=\!\!x$, где $u$ - символ, а $x$ -
непустая конечная цепочка символов, где $u$ - называется левой частью
правила, $x$ - правой.

__9. Определение 2__

_Грамматикой_ $G[z]$ называется конечное, непустые множество правил.

$z$ - это символ, который должен встертиться в левой части по крайней
мере одного правила.

Он называется начальным символом.
Все символы, которые встречаются в левых и правых частях правил, образуют
словарь $V$.

пчс - последовательность чисел.

__Пример__
```
Грамматика G1[<число>]
<число>::=<пчс>
<пчс>::=<пчс><цифра>
<пчс>::=<цифра>
<цифра>::=0
<цифра>::=1
...
<цифра>::=9
```

Словарь $V$ для этой грамматики следующий:
$$V=\{0,1,2,3,4,5,6,7,8,9, \; \text{<цифра>, <пчс>, <число>}\}.$$

__10. Определение 3__

В заданной грамматике $G$ символы, которые встречаются в левой части правил,
называются _нетерминальными_.
Они образуют множество нетерминальных символов $V_N$.
Символы, которые не входят в множество $V_N$, называется терминальными.
Они образуют множество $V_T$.
Таким образом $V = V_N V_T$.

Нетерминалы будем заключать в угловые скобки $<$ $>$, чтобы отличить
их от терминалов.

В грамматике $G1$ символы $0,1,2,3,\ldots,9$ - терминалы;
число, ПЧС, цифра - нетерминалы.

Множество правил с одинаковой левой частью будем записывать
$V\!\text{::} x|y|\ldots|z$.

Тогда $G1$ будет выглядеть следующим образом:
```
<число>::=<пчс>
<пчс>::=<пчс><цифра>/<цифра>
<цифра>::=0|1|2|3|...|9
```

Такая форма записи называется нормальной формой Бэкуса (НФБ) или формой
Бэкуса-Наура.

__11. Определение 4__

- Пусть $G$ - грамматика. Мы говорим, что цепочка $V$ непосредственно
порождает цепочку $w$ и обозначаем $V\!=>\!w$, если для некоторых цепочек
$x$ и $y$ можно написать: $V=xUy,\ w=xuy$ где $U\text{::}\!\!=\!u$ - правило грамматики
$G$.
Мы также говорим, что $w$ - непосредственно выводима из $V$, цепочки $x$ и
$y$ могут быть пустыми.

__12. Определение 5__

Говорят $V$ порождает $w \qquad V \! =>\!\!{}^+w$, если существует последовательность
непосредственных выводов $V=u_0=>u_1=>u_2=>\ldots=>u_n=w \qquad\qquad n>0$.
Эта последовательность называется _выводом длины_ $n$.

Говорят, также, что цепочка $w$ является _словом_ $V$.
Наконец, пишут $V \! => \!\! {}^*w$, если $V \! => \!\!+w$ или $V=w$;

__13. Пример__

|$V$|$w$|Использованные пр.|$x$|$y$|
|:-:|:-:|:-:|:-:|:-:|
|<число>=><пчс>=><пчс><цифра>=><цифра><цифра>=>7<цифра>=>|<пчс><пчс><цифра><цифра><цифра>7<цифра>75|$\begin{matrix} 1 \\ 2 \\ 3 \\ 6 \\ 6 \end{matrix}$|$\begin{matrix} \lambda \\ \lambda \\ \lambda \\ \lambda \\ 7 \end{matrix}$|$\begin{matrix} \lambda \\ \lambda \\ \text{<цифра>} \\ \text{<цифра>} \\ \lambda \end{matrix}$|

<число>=><пчс>=><пчс><цифра>=><цифра><цифра>=>7<цифра>=>75, таким образом
<число>=>75 и длинна вывода = 5.

__14. Определения 6 и 7__

__Определение 6:__

- Пусть $G[z]$ - грамматика.
Цепочка $x$ называется сентенциальной формой, если $x$ выводима
из начального символа $z, \;\; z \! => \!\! {}^*x$.
- _Предложение_ - это сентенциальная форма, состоящая из терминальных
символов.

__Определение 7:__

- Язык $L(G[z])$ - это множество предложений:
$$L(G)=\{x \, | \;\; z \! => \!\! {}^*x \; \text{и} \;\; x \: V_{T^+}\}.$$
- Таким образом, язык - это просто подмножество множества всех терминальных
цепочек, т.е. цепочек в $V_T$.
Структура предложений задается грамматикой.
Несколько различных грамматик могут порождать один и тот же язык.

__15. Определение 8__

- Пусть $G[z]$ - грамматика.
И пусть $w = xUy$ - тогда $u$ называется фразой сентенциальной формы $w$
для нетерминального символа $U$, если
$z \! => \!\! {}^* \;\; xUy$ и $U \!\! => \!\! +u$ и простая,
$z \!\! => \!\! {}^* \; xUy$ и $U \!\! => \!\! u$.\
Следует быть осторожным с терминалом фраза.
Тот факт, что $U \!\! => \!\! +u$ вовсе не означает, что $u$ является фразой
сентенциальной формы $xuy$, необходим $z \!\! => \!\! {}^* \;\; xUy$.
- В качестве примера рассмотрим сентенциальную форму <пчс>1.
- Значит ли, что <пчс> - является фразой, если существует правило
<число>::=<пчс>? - нет, т.к. невозможно вывод <число>1 начального символа
<число>. Имеет место вывод: $$\text{<число>=><пчс>=><пчс><цифра>=><пчс>1.}$$
- Таким образом: $$\text{<число>=>*<пчс> и <пчс>=>}^+\text{<пчс>1}$$ $$\text{<число>=>*<пчс><цифра> и <цифра>=1}$$
Тогда <пчс>1 и 1 фразы; 1 - простая фраза.

__16. Определение 9__

Основой всякой сентенциальной формы называется самая левая простая фраза.

Грамматика $G1$ описывает бесконечный язык, т.к. существует правило
<пчс>::=<пчс><цифра>.

В общем случае, если $U \!\! => \!\! {}^+ \ldots U \ldots$, мы говорим,
что грамматика _рекурсивна_.
Если $U \!\! => \!\! +U\ldots$, то левая рекурсия,
$U \!\! => \!\! {}^+\ldots U$ - правая.

___17. Определение 10__

- Если две различные грамматики порождают один и тот же язык, то эти
грамматики называются _эквивалентными_.\
Эквивалентные грамматики могут обладать разными свойствами, облегчающими
или, наоборот, затрудняющими разработку алгоритма трансляции (перевода).
- Каждой сентенциальной форме по определению соответствует, по крайней
мере один вывод.
Однако, одной и той же сентенциальной форме может соответствовать более,
чем один вывод.
Вывод можно наглядно представить синтаксическим деревом, которое иначе
называют _деревом вывода_ или _деревом разбора_.
В качестве иллюстрации построим дерево вывода предложения - 75.

__18. Определение 10 (часть 2)__

- _Отправляясь от начального символа <число> нарисуем его куст, для того,
чтобы указать первый непосредственный вывод:_
$$\begin{matrix} \text{Число} \\ \vert \\ \text{<пчс>} \end{matrix}$$

_Куст узла - это множество подчиненных узлов (символов), образующих цепочку,
которая заметает имя куста, в непосредственном выводе._

_Концевые узлы не имеют подчиненного куста.
Для второго вывода получаем:_
$$\begin{matrix} \text{Число} \\ \vert \\ \text{<пчс>} \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ \text{<пчс>} \quad \text{<цифра>} \end{matrix}$$

__19. Определение 10 (часть 3)__

__Строим три синтаксические диаграммы, каждый раз применяя непосредсвенный
вывод.__

$$\begin{matrix} \text{<число>} \\ \vert \\ \text{<пчс>} \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ \text{<пчс>} \quad \text{<цифра>} \\ \vert \qquad \qquad \\ \text{<цифра>} \qquad \qquad \\ {} \\ {} \end{matrix} \qquad
\begin{matrix} \text{<число>} \\ \vert \\ \text{<пчс>} \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ \text{<пчс>} \quad \text{<цифра>} \\ \vert \qquad \qquad \\ \text{<цифра>} \qquad \qquad \\ \vert \qquad \qquad \\ 7 \qquad \qquad\end{matrix} \qquad
\begin{matrix} \text{<число>} \\ \vert \\ \text{<пчс>} \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ \text{<пчс>} \quad \text{<цифра>} \\ \vert \qquad \qquad \qquad \vert \\ \text{<цифра>} \qquad  5 \\ \vert \qquad \qquad \\ 7 \qquad \qquad\end{matrix}$$

__20. Определение 10 (часть 4)__

- При чтении слева направо концевые узлы образуют цепочку, вывод которой
представлен деревом.
Можно восстановить вывод по синтаксическому дереву при помощи обратного 
процесса.
Самый правый концевой указывает непосредственный вывод
7<цифра>=>75, чтобы пройти по синтаксическому дереву до куста
7<цифра> мы отсекаем куст от дерева - удалаем его.
Продолжаем процесс, всегда восстанавливая последний непосредсвенный вывод.
Концевые узлы дерева образуют выводимую сентенциальную форму.

__21. Определение 11__

- Предложение грамматики _неоднозначно_, если для его вывода
существует два синтаксических дерева.
Грамматика _неоднозначна_, если она допускает неоднозначные
предложения, в противном случае она однозначна.
- Заметим, что мы называем _неоднозначной_ грамматику, а не
сам язык.
Изменяя неоднозначную грамматику, но не заменяя её
предложения, можно получить однозначную грамматику для того
же множества предложений.
Однако, есть языки, для которых не существует однозначной
грамматики.
Такие языки называются _существенно неоднозначными_.
Было доказано, что проблема распознавания неоднозначности
алгоритмически не разрешима (т.е. не существует алгоритма,
определяющего законченное число шагов однозначана или нет.
Проблема Поста).
Но можно разработать условие такие, что если грамматика удовлетворяет им,
то она однозначна.

__22. Пример__

$${\lbrace a^i b^i c^j \: | \; i,j \geq 1 \rbrace} \cup {\lbrace a^i b^i c^j \: | \; i,j \geq 1 \rbrace}$$

&nbsp;

___

&nbsp;

## __2. Задача разбора (WIP - completed, normalize length) (3170 chars) (Topic 1: pra3: 23. -> 26.)__

&nbsp;

Разбор сентенциальной формы означает построение вывода и,
возможно, синтаксического дерева для неё.
Программу разбора также называют распознавателем, т.к. она
распознает только предложения рассматриваемой грамматики
(например, мы можем распознавать программы, написанные на
языке программирования).

Различают две категории алгоритмов разбора:
1. _нисходящий_ (сверху вниз)
2. _восходящий_ (снизу вверх).

Эти термины соответствуют способу построения синтаксических
деревьев.
При нисходящем разборе дерево строится от корня (начального
символа) вниз к концевым узлам.
Рассмотрим предложение 35 в следующей грамматике целых чисел.

__Схема:__

$$N \Coloneqq \text{Д}|N\text{Д}$$

$$\text{Д} \Coloneqq 0|1|2|3|4|5|6|7|8|9$$

$$
\begin{matrix} N \\ \\ \\ \\ \\ \\ \\ \\ \\ \end{matrix} \qquad
\begin{matrix} N \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ N \qquad \quad \;\; \text{Д} \\ \\ \\ \\ \\ \end{matrix} \qquad
\begin{matrix} N \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ N \qquad \quad \;\; \text{Д} \\ \vert \qquad \qquad \\ \text{Д} \qquad \qquad \\ \\ \\ \end{matrix} \qquad
\begin{matrix} N \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ N \qquad \quad \;\; \text{Д} \\ \vert \qquad \qquad \\ \text{Д} \qquad \qquad \\ \vert \qquad \qquad \\ 3 \qquad \qquad \end{matrix} \qquad
\begin{matrix} N \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ N \qquad \quad \;\; \text{Д} \\ \vert \qquad \qquad \vert \\ \text{Д} \qquad \quad \;\;\; 5 \\ \vert \qquad \qquad \\ 3 \qquad \qquad \end{matrix} \qquad
$$

На каждом последующем шаге самый левый элементарный
символ $V$ текущей сентенциальной формы $xVy$
заменяется на правую часть правила $V \Coloneqq u$,
в результате получается следующая сентенциальная форма.
Этот процесс для предложения 35 представлен в виде пяти (5)
деревьев.
Требуется получить сентециальную форму, которая совпадает с
заданной цепочкой.

Метод восходящего разбора состоит в том, что цепочки, отправляясь от
заданной, пытаются привести её к начальному символу.
На первом шаге терминал 3 приводится к $\text{Д}$, в
результате чего
получается сентенциальная форма $\text{Д5}$.

__Результат__

(рисунок нужно смотреть справа налево)

$$
\begin{matrix} N \\ \\ \\ \\ \\ \\ \\ \\ \\ \end{matrix} \qquad
\begin{matrix}N \\ \vert \\ \_\_\_\_\_\_\_\_ \\ \vert \qquad \qquad \vert \\ N \qquad \quad \;\; \text{Д} \\ \vert \qquad \qquad \vert \\ \text{Д} \qquad \quad \;\;\; 5 \\ \vert \qquad \qquad \\ 3 \qquad \qquad \end{matrix} \qquad \quad
\begin{matrix} \\ \\ \\ \\ N \qquad \text{Д} \\ \vert \qquad \;\; \vert \\ \text{Д} \qquad \; 5 \\ \vert \qquad \;\;\; \\ 3 \qquad \;\;\; \end{matrix} \qquad \qquad \quad
\begin{matrix} \\ \\ \\ \\ N \qquad \;\; \\ \vert \qquad \;\;\; \\ \text{Д} \qquad \; \text{Д} \\ \vert \qquad \;\; \vert \\ 35 \qquad 35 \end{matrix} \qquad \qquad
$$

$$N => N \; \text{Д} => N5 => \text{Д5} => 35$$

Выводы, произведенные двумя распознавателями, различны, но имеют одно
и то же синтескическое дерево.
При разборе слева направо цепочка справа от основы всегда содержит только
терминальные символы.

&nbsp;

___

&nbsp;

## __Тема 1. Вопрос 3. Классификация грамматик по Хомскому (около 2115 символов) (pra3: 28-30)__

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

Грамматика по Хомскому - это четверка $(V, T, P, Z)$, где:
- $V$ - алфавит НЕтерминальных символов.
- $T$ - алфавит терминальных символов $(T \cap V = \varnothing)$.
- $P$ - конечный набор правил постановки.
- $Z$ - начальный символ, который не является терминалом $(Z \in V - T)$.

Рассматриваемая грамматика разделяется на четыре (4) типа:
- Тип 0 - грамматики с фазовой структурой;
- Тип 1 - контекстно-зависимые (КЗ) грамматики и неукорачивающие
грамматики;
- Тип 2 - контекстно-свободные (КС) грамматики;
- Тип 3 - регулярные грамматики.

Различие четырех типов грамматик заключается в форме правил подстановки,
допустимых в $P$.

0. Говорят, что $G$ - это грамматика с фазовой структурой (тип 0), если
правила имеют
вид: $$u \Coloneqq U, \qquad \text{где} \qquad u \in V^{+}; \qquad U \in V^{*},$$
т.е. левая часть $u$ может быть тоже последовательностью символов, а
правая - пустой.
Грамматики с фазовой структурой имеют небольшое употребление.
1. Если ввести ограничения на правила подстановки, то получится класс
контекстно-зависимых (КЗ) языков (тип 1).
Правила подстановки имеют
вид: $$xUy \Coloneqq xuy, \qquad \text{где} \qquad U \in V-T; \qquad u \in V^{+}; \qquad x, y \in V^{*}.$$
Термин контекстно-зависимые отражает тот факт, что можно заменить $U$ на
$u$ в контексте $x{\lbrace U, u \rbrace}y$.
2.  Дальнейшее ограничение правил подстановки дает класс грамматик,
называемых контекстно-свободными (КС): $$U \Coloneqq u, \qquad \text{где} \qquad U \in V-T \qquad \text{и} \qquad u \in V^{*}.$$
Как раз-таки с помощью КС-грамматики и описываются все языки
программирования.
    - Также В КС-грамматиках может появиться правило
    вида $U \Coloneqq \lambda$.\
    По заданной КС-грамматике $G$ можно сконструировать неукорачивающую
    грамматику типа $G1$ или $\lambda$ - свободную, такую, что
    $L(G1) = L(G) - {\lbrace \lambda \rbrace}$.
3.  Если мы ограничим правила ещё раз, приведя их к
виду: $$U \Coloneqq u \qquad \text{или} \qquad U \Coloneqq WN, \qquad \text{где} \qquad N \in T^{*}; \qquad U, W \in V-T,$$
то получим регулярную грамматику (тип 3).

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

___

&nbsp;

## __4. Диаграмма состояний (WIP - completed, normalize length) (3032 chars) (Topic 1: pra3: 31 -> 34; pra4: 35 -> 36)__

&nbsp;

Рассмотрим регулярную диаграмму $\mathbf{G[z]}$:
- $Z \Coloneqq V0 \; \vert \; V1$
- $U \Coloneqq Z1 \; \vert \; 1$
- $V \Coloneqq Z0 \; \vert \; 0$

Порожденный ею язык состоит из последовательностей образуемых парами 01 или
10, т.е. $L(G) = \lbrace B \;\: | \, n>0 \rbrace$, где
$B = \lbrace 01, 10 \rbrace$.

Чтобы облегчить распознавание предложений грамматики $G$ нарисуем диаграмму
состояний.

![СЛАЙД 32 НЕ ОТОБРАЖАЕТСЯ](images/img_2022_10_14_FaWwNL_pra3_slide32.jpg)

В этой диаграмме каждый нетерминал грамматики $G$ представлен узлом или
состоянием.
Кроме того, есть начальное состояние $S$ (предполагается, что грамматика не
содержит нетерминала $S$).

Каждому правилу $Q \Coloneqq T$ соответствует дуга с пометкой $T$,
направленная от начального состояния $S$ к состоянию $Q$.

Каждому правилу $Q \Coloneqq KT$ соответствует дуга с пометкой $T$,
направленная от состояния $K$ к состоянию $Q$.

Диаграммы состояний используются, чтобы распознать или разработать цепочку
$x$ следующим образом:

1. Первым текущим состоянием считать $S$. Начать с самой левой литеры в
цепочке $x$ и повторить шаг 2 до тех пор, пока не будет достигнут конец $X$.
2. Сканировать следующую литеру $x$, продвинуться по дуге, помеченной этой
литерой, переходя к следующему текущему состоянию.
    - Если при каком-то повторении шага 2 такой дуги не оказывается, то цепочка
    $x$ - не является предположением языка и происходит остановка.
    - Если мы достигнем конца $x$, то $x$ предложение тогда и только тогда, когда
    последнее текущее состояние есть $Z$.

На каждом шаге, кроме первого, основой является имя текущего состояния, за
которым следует входной символ.
Символ, к каждому приводится основа, будет именем следующего состояния.

__Пример:__

![СЛАЙД 34 НЕ ОТОБРАЖАЕТСЯ](images/img_2022_10_14_FaWwNL_pra3_slide34.jpg)

Каждая строка отражает состояние разбора перед началом
выполнения шага 2.

В этом примере разбор выглядит столь простым благодаря
характеру правил, т.к. нетерминалы встречаются лишь как первые символы
правой части.
На первом шаге первый символ предложения всегда приводится к нетерминалу.
На каждом последующем шаге первые два символа $VT$ синтециальной формы
$VTt$ приводится к нетерминалу $U$, при этом используется правило
$U \Coloneqq VT$.
При выполнении этой редукции имя текущего состояния $U$, а имя следующего
текущего состояния $V$.
Т.к. каждая правая часть единственна, то единственным оказывается $U$
символ, к которому она приводится.

Синтаксические деревья для предложений регулярных грамматик всегда имеют
вид, подобный изображенному.

Чтобы избавиться от проверки на каждом шаге, есть ли дуга с
соответствующей пометкой, можно добавить ещё одно состояние $F$ (неудача) и
добавить все необходимые дуги от всех состояний к $F$.
Добавляется также дуга, помеченная всеми возможными литерами ведущая из $F$
обратно в $F$. В результате диаграмма имеет вид:

![СЛАЙД 36 НЕ ОТОБРАЖАЕТСЯ](images/img_2022_10_21_FaWwNL_pra4_slide36.jpg)

&nbsp;

___

&nbsp;

## __Тема 1. Вопрос 5. Конечный автомат (около 1627 символов) (pra4: 37-39)__

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

Детерминированный автомат с конечным числом состояний
(или же __конечный автомат__, КА) - это пятерка
$(K, \; VT, \; M, \; S, \; Z)$, где:
- $K$ - алфавит элементов, называемых состояниями;
- $VT$ - алфавит, называемый входным алфавитом
(литеры, которые могут встретиться в цепочке или предложении);
- $M$ - отображение (или функция) множества $K \times VT$ во
множество $K$ (если $\overline{M}(Q,T)=R$, то это означает, что из
состояния $Q$ при входной литере $T$ происходит переключение в
состояние $R$);
- $S$ - начальное состояние $(S \in K)$;
- $Z$ - непустое множество заключительных состояний $(Z \subset K)$.

Такие автоматы называются __детерминированными__, т.к. на каждом шаге
входная литера однозначно определяет следующее текущее состояние.

Определим формально, как работает КА с входной цепочкой $t$, расширив
понятие отображение, которое указывает, как переключаются состояния в
зависимости от входной литеры.

Определим:
1. $M(Q, \lambda) = Q$ при любом состоянии $Q$:
    - что означает, что если на входе пустой символ, то состояние
    остается прежним.
2. $M(Q, \; Tt) = M(M(Q,T), \; t)$ для любых $t \in VT^*$ и
любых $T \in VT$:
    - что показывает, что в состоянии $Q$ и при входной цепочке $Tt$ мы
    применяем $M$, чтобы перейти в состояние $P=M(Q, \; T)$, а затем
    применяем отображение $M(P,t)$.

КА допускает цепочку, если $M(S,t) = P$, где состояние $P$ принадлежат
множеству заключительных состояний $Z$.

Также справедливо такое утверждение, что если предложение $x$ принадлежит
грамматике $G$, то оно также допускается КА, соответствующим
грамматике $G$.

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

___

&nbsp;

## __Тема 1. Вопрос 6. Представление автоматов (около 1592 символов) (pra4: 41-42)__

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

### ___Способы представления конечных автоматов___

&nbsp;

Мы рассмотрели два (2) способа представления конечных автоматов (КА):
- таблица (матрица) переходов;
- списочная структура.

&nbsp;

### ___Таблица (матрица) переходов___

&nbsp;

__Таблица переходов__ является одним из удобных способов представления КА.

КА с
- состояниями $S_1, \ldots, S_n$
- и
- входными литерами $T_1, \ldots, T_m$
- можно представить в виде матрицы $B$,
- состоящей из $n \times m$ элементов.

Элемент $B[i, j]$ содержит число $k$
${\left( \textit{номер состояния} \; S_k \right)}$ такое, что
$$M[S_i, T_j] = S_k.$$

Можно условиться, что состояние $S_1$ - начальное, а список заключенных
состояний представлен вектором.

$$
\begin{vmatrix}
\hline
0 \\ \\ 0 \\ \\ 1 \\ \\ 0 \\ \\ 1 \\ \\
\ldots \\
\\
\hline
\end{vmatrix} \;
\begin{matrix}
\\
\leftarrow \text{не закл.} \\ \\
\\ \\
\leftarrow \text{закл.} \quad \; \\ \\
\\ \\ \\ \\ \\ \\ \\
\end{matrix}
$$

Матрица переходов имеет такое название, потому что она указывает, каким
образом происходит переключение из одного состояния в другое.

&nbsp;

### ___Списочная структура___

&nbsp;

Теперь рассмотрим способ представления КА в виде __списочной структуры__.

Представление каждого состояния с $k$ дугами, исходящими из него, занимает
$2k+2$ слов, где:
- первое слово - имя состояния;
- второе слово - значение $k$.

Каждая последующая пара слов содержит:
- терминальный символ из входного алфавита;
- указатель на начало представления состояния, в которое надо
перейти по этому символу.

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

___

&nbsp;

## __7. Моделирование в компьютерной лингвистике (WIP - completed, normalize length) (2497 chars) (Topic 2: pra7: 13. -> 16.)__

&nbsp;

### ___13. Определения___

1. ___Валентность___ - это способность слова или другой единицы языка
присоединять другие единицы определенным синтаксическим способом;
2. ___Актант___ - это слово или синтаксическая конструкция, заполняющая эту
валентность.

Например, русский глагол _передать_ имеет три основные валентности, которые
можно выразить следующими вопросительными словами: ___кто? кому? что?___

_В рамках генеративного подхода валентности слов (прежде всего, глаголов)
описываются преимущественно в виде специальных фреймов (subcategorization
frames), а в рамках подхода, основанного на деревьях зависимостей - как
моедли управления._

### ___14. Модель "Смысл <=> Текст"___

В соответствии с этой теорией ЕЯ рассматривается как особого рода
преобразователь, выполняющий _переработку заданных смыслов_ в
соответствующие им тексты и заданных текстов в соответствующие им смыслы.

Под смыслом понимается инвариант всех синонимичных преобразований текста.
Содержание связного фрагмента речи без расчленения на фразы и словоформы
отображается в виде специального семантического представления, состоящего
из двух компонент:
- _семантического графа_ и сведений о _коммуникативной организации смысла_.

### ___15. Модель "Смысл <=> Текст". Отличительные особенности теории___

1. Ориентацию на синтез текстов (способность порождать правильные тексты
рассматривается как основной критерий языковой компетенции);
2. Многоуровневый, модульный характер модели, причем основные уровни языка
разделяются на поверхностный и глубинный уровень: различаются, к примеру,
_глубинный_ (семантизированный) и _поверхностный_ ("чистый") синтаксис, а
также поверхностно-морфологический и глубинно-морфологический уровни;
3. Интегральный характер модели языка; сохранение информации, представленной
на каждом уровне, соответстующим модулем, выполняющими переход с этого
уровня на следующий;
4. Специальные средства описания синтактики (правил соединения единиц) на
каждом из уровней; для описания лексической сочетаемости был предложен
набор _лексических функций_, при помощи которых сформулированы
правиласинтаксического перифразирования;
5. Упор на словарь, а не на грамматику; в словаре хранится информация,
относящася к разным уровням языка; в частности, для синтаксического анализа
используются модели управления слов, описывающие их синтаксические и
семантические валентности.

Эта теория и модель языка нашли свое воплощение в системе машинного перевода
ЭТАП.

&nbsp;

___

&nbsp;

## __8. Требования, предъявляемые к моделям типа «Смысл <=> Текст» (WIP - completed, normalize length) (2830 chars) (Topic 2: pra4: 6. -> 9.)__

&nbsp;

Общие требования, предъявляемые к моделям типа "Смысл $<=>$ Текст":

1. Модель "Смысл $<=>$ Текст" должна быть действующей моделью.
Она представляет собой устройство, имеющее вход и выход и перерабатывающее
то, что подается ему на вход (задание), в нечто другое, что выдается на его
выходе (результат).  Принципиальная динамичность таких моделей резко
противопоставлена статичности более традиционных классифицирующих
(таксономических) описаний.\
В модели "Смысл $<=>$ Текст" различаются: 
    - "лингвистическая" часть, в которой собраны сведения о данном языке
    (т.е. соответствия "смыслы $<=>$ тексты") и которая представляет собой
    _исчисление_, т.е. перечень разрешений и запрещений
    (что можно/нельзя делать), а не алгоритм, т.е. набор предписаний
    (что надо делать);
    - "алгоритмическая" часть, в которой содержится описание механизма
    (или процедур) использования сведений о языке и которая поэтому носит
    действительно алгоритмический характер.
2. Модель "Смысл $<=>$ Текст" должна быть задана _совершенно формально_ -
посредством однозначных и логически последовательных формулировок, не
требующих привлечения какой-либо добавочной информации.
В качестве контрольного критерия выдвигается принципиальная осуществимость
модели или любого ее фрагмента на вычислительной машине.
3. Модель "Смысл $<=>$ Текст" есть _не порождающее_, а _преобразующее
устройство_ - не генератор текстов, а транслятор смыслов в тексты и
обратно.
Этим она отличается от порождающей грамматики в смысле Хомского, цель
которой - задавать (перечислять) все грамматически правильные
(или все осмысленные) фразы привлекаемых языков.
От модели "Смысл $<=>$ Текст" требуется только умение переработать в
соответствующие тексты содержательно _любое_ "смысловое задание" (при
условии, разумеется, что оно представлено в том формальном виде, т.е.
на том "смысловом" языке, который принят для данной модели) и наоборот -
извлечь из заданного текста его "смысл" или "смыслы".\
Не занимаясь самим смыслом, модель типа "Смысл $<=>$ Текст" отвечает за
формальную правильность текстов и за правильное соответствие текстов и
смыслов.

Другими словами, такая модель обязана:

- a) при движении от смылса к тексту исключать построение "абсолютно"
неправильных фраз, а при обратном движении - обнаруживать "абсолютную"
неправильность предъявленных фраз;
- б) обеспечивать приписывание любому заданному смыслу "$\text{Ф}$" всех
правильных
относительно этого смысла фраз $\text{Фi}$ и только таких фраз, а также
приписывание любой заданной фразе $\text{Ф}$ всех смылсов "$\text{Фi}$",
относительно
которых эта фраза является правильной, и только таких смыслов.
(Мы говорим здесь именно о фразах просто для большей определенности;
в действительности, имеются в виду смыслы и тексты любого объема.)

&nbsp;

___

&nbsp;

## __Тема 2. Вопрос 9. В настоящем варианте модель «Смысл <=> Текст» предполагает пять основных уровней представления. (около 1404 символов) (pra5: 13-16)__

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

В настоящем варианте модель «Смысл <=> Текст» предполагает следующие
пять (5) основных уровней представления:
1. __Семантический уровень__ - изображение содержания связного фрагмента
речи (= высказывания), без расчленения на фразы и слова, в виде так
называемого _семантического представления_.
2. __Синтаксический уровень__, который расчленен на два подуровня:
    - "__Глубинный синтаксис__" - изображение высказывания в виде
    последовательности _глубинно-синтаксических представлений_ фраз (ГСП);
    - "__Поверхностный синтаксис__" - изображение высказывания в виде
    последовательности _поверхностно-синтаксических представлений_
    фраз (ПСП).
3. __Морфологический уровень__, который также расчленен на два подуровня:
    - "__Глубинная морфология__" - изображение фразы в виде ее
    _глубинно-морфологического представления_ (ГМП);
    - "__Поверхностная морфология__" - изображение фразы в виде ее
    _поверхностно-морфологического представления_ (ПМП).
4. __Фонологический уровень__ - _фонемная транскрипция фразы_, т.е.
последовательность символов, представляющих фонемы и просодемы
(фонологически релевантные просодические явления).
5. __Фонетический уровень__ - _фонетическая транскрипция фразы_, т.е.
последовательность символов, представляющих звуки речи и просодические
явления - просодии (словесные и фразовые ударения, тоны, интонации, паузы,
стыки и т.п.).

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

___

&nbsp;

## __10. Переходы от одного уровня представления высказывания к другому выполняются следующими четырьмя основными компонентами модели «Смысл  <=>Текст». (WIP - completed, normalize length) (2141 chars) (Topic 2: pra5: 16. -> 19.)__

&nbsp;

Переходы от одного уровня представления высказывания к другому выполняются
следующими четырьмя основными компонентами модели "Смысл <=> Текст".
1. Семантический компонент должен обеспечивать установление соответствий
между данным семантическим представлением и последовательностью
глубинно-синтаксических представлений фраз, которые образовали бы текст,
отвечающий этому семантическому представлению.
2. Синтаксическому компоненту поручаются соответствия между
глубинно-синтаксическими представлениями фраз и их глубинно-морфологическими
представлениями, которые состоят из цепочек глубинно-морфологических
представлений (ГМП) словоформ, отвечающих этим фразам, и сведений о
просодических характеристиках фраз.
3. Морфологический компонент данной модели устанавливает соответствия между
глубинно-морфологическим представлением отдельной словоформы и
соответствующей словоформой в фонемной транскрипции.
4. Фонологический компонент, к которому мы (достаточно условно) относим и
графическо-орфографические правила, при синтезе преобразует фонемную
транскрипцию словоформы либо в ее детализированное фонетическое
представление, либо в принятую офрографическую запись, а при анализе
выполняет обратные операции.

Каждый из четырех названных компонентов модели "Смысл <=> Текст" повторяет
внутри себя строение всей модели.
А именно, отдельный компонент модели также описывается как состоящий из
нескольких независимых и работающих последовательно преобразователей,
характеризующихся множественостью выходов; каждый перебирает результаты
предыдущего, обрабатывая их, в свою очередь, один за другим.

Таким образом, можно сказать, что каждый компонент модели и каждый
преобразователь внутри этого компонента суть _генераторы_ либо синонимичных
представлений данного содержания на более поверхностном уровне, либо
взаимоисключающих толкований некоторого выражения на более глубинном
уровне.
Одновременно в каждом компоненте и в каждом проебразователе внутри
компонента содержится _селектор_ - набор сведений, позволяющих браковать
недопустимые с точки зрения данного уровня варианты, выданные с
предыдущего уровня.

&nbsp;

___

&nbsp;

## __Тема 2. Вопрос 11. Толково-комбинаторный словарь (ТКС). Словарная статья такого словаря. (около 1470 символов) (pra5: 21-22)__

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

### ___Толково-комбинаторный словарь (ТКС)___

&nbsp;

Модель "Смысл <=> Текст" существенным образом использует большое количество
сведений о каждом слове рассматриваемого языка.
Эти сведения могут быть представлены в особом словаре, который мы называем
__толково-комбинаторным словарем__ (ТКС) и который занимает в описываемой
модели важное место.

&nbsp;

### ___Словарная статья такого словаря___

&nbsp;

__Словарная статья__ такого словаря должна в идеале содержать все
- словоизменительные,
- словообразовательные,
- синтаксические,
- семантические
- и
- стилистические

характеристики _заглавного_ (или _ключевого_) слова $C_0$.

Кроме того, для $C_0$, необходимо указать все слова (или словосочетания),
определенным образом связанные с ним по смыслу, а именно:
1. его "_парадигматические варианты_" (или "_замены_") - средства, которые
могут или должны заменять $C_0$ в тех или иных контекстах и при тех
или иных условиях;
2. его "_синтагматические партнеры_" (или "_параметры_") - средства,
которыми идиоматично, т.е. несвободно, выражаются при данном слове
некоторые смыслы.

Для обозначения
- парадигматических вариантов
- и
- синтагматических партнеров

сло&#769;ва мы используем термин _лексические корреляты_.
Стремление достаточно по&#769;лно и систематически представить в словарной
статье каждого слова все его лексические корреляты составляет
__одну из главных__ особенностей _толково-комбинаторного словаря_.

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

___

&nbsp;

## __12. Лексические функции. Стандартная в данном языке лексическая функция (СЛФ) (WIP - completed, normalize length) (2604 chars) (Topic 2: pra5: 23. -> 25.; pra6: 26.)__

&nbsp;

Зависимости, связывающие слова с их лексическими коррелятами, предлагается
описывать с помощью _лексических функций_ (ЛФ).
Лексические функции вводятся как средство описания
_лексической сочетаемости_, а не семантики; тем не менее мы можем
представлять себе ЛФ как весьма общий, не всегда достаточно точно
определенный смысл (в частности, "нулевой") - такой, что его нужное в данном
речевом контексте выражение однозначно (с точностью до синонимии) выбирается
по тому конкретному слову или словосочетанию $C_0$, при котором или для
которого этот смысл выражается.

Среди всевозможных лексических функций мы рассматриваем только те,
_у которых имеются фразеологически связанные выражения_, т.е. те, у которых
есть выражения, допустимые при одних аргументах, но не допустимые при
других. (Такие ЛФ, у которых все выражения возможны при любых аргументах,
или _ЛФ-константы_, не представляют содержательного интереса с точки зрения
описания лексической сочетаемости.)

Среди ЛФ, имеющих фразеологически связанные выражения, различаются
стандарнтые и нестандартные ЛФ.

Стандартная в данном языке лексическая функция (СЛФ) должна - в отличие от
нестандартной ЛФ - удовлетворять двум следующим требованиям:

(1) СЛФ имеет достаточно широкую семантическую сочетаемость, т.е.
соответствующий смысл образует допустимые комбинации с достаточно большим
числом разных смыслов.
Иначе говоря, СЛФ должна быть определена для достаточно большого числа
аргументов.
Это свойство не зависит от языка.

(2) СЛФ характеризуется достаточным богатством ее языковых выражений.
Это свойство, разумеется, полностью зависит от языка.

Примером смысла, имеющего в русском языке (и целом ряде других языков)
фразеологически связанные выражения и при этом удовлетворяющего обоим
требованиям, является смысл "очень" ($\approx$ "крайний",
"в высшей степени"); ясно, что он применим к огромному количеству слов
(требование 1); при этом он имеет необычайно много разных выражений,
например:
- "очень" (болен) = тяжело;
- "очень" (здоров) = абсолютно, полностью, совершенно, как бык;
- "очень" (от- чаяние) = глубокое, полное;
- "очень" (брюнетка) = жгучая;
- "очень" (худой) = необычайно, как щепка, как скелет;
- "очень" (мороз) = трескучий;
- "очень" (беречь) = как зеницу ока;
- "очень" (негодяй) = отъявленный... (требование 2).

Из этих ил- люстраций непосредственно видно, что нужное выражение смысла
"очень" выбирается по ключевому слову, стоящему в скобках, т.е. является
фразеологически связанным.
Таким образом, этот смысл должен быть признан стандартной лексической
функцией.

&nbsp;

___

&nbsp;

## __13. Примеры лексических функций. (WIP - completed, normalize length) (3907 chars) (Topic 2: pra6: 28. -> 40.)__

&nbsp;

1. __Syn__ - синоним: слово, совпадающее со свои ключевым словом $C_0$ по
смыслу, принадлежащей к той же части речи, что и $C_0$, и имеющее такие же
активные синтаксические валентности.

2. __Conv__ - конверсив: слово, которое называет то же самое отношение, что
и ключевое слово $C_0$, но взятое "в ином направлении", т.е. с
перестановкой тех же актантов на другие места (точнее: с изменением
соответствия между семантическими переменными и глубинно-синтаксическими
актантами).
Регулярным способом образования конверсивов во многих языках является
пассив: _Ученый проводит анализ - Анализ проводится ученым._

3. __Anti__ - антоним: слово, обозначающее свойство, состояние или действие,
"противоположное" свойство, состоянию или действию, обозначенному ключевым
словом $C_0$.

4. __Der__ - синтаксический дериват: слово, совпадающее с $C_0$ по смыслу,
но принадлежащее к другой части речи.
Поскольку мы различаем четыре основные части речи:
S - существительное,
A - прилагательное,
Adv - наречие и
V - глагол,
имеется четыре вида дериватов:
$S_0$, $A_0$, $Adv_0$ и $V_0$.

5. __Gener__ - название понятия, родового по отношению к понятию,
обозначенному ключевым словом $C_0$.

6. $\mathbf{S_i}$ $(i = 1, 2, 3, 4)$ - типовое название $i$-го актанта.

7. __Sc__ - типовые названия второстепенных компонентов ситуации -
сирконстантов, таких, как место, инструмент, способ действия и т.п.

8. Соотносительные лексические функции __Sing__ (лат. _singulus_
'отдельный'; "единичность") - типовое название одной "штуки", одного
"кванта" некоторого $C_0$ - и __Mult__ (лат. _multum_ 'множество';
"множественность") - типовое название совокупности, множества $C_0$.

9. __Figur__ ("фигуральное обозначение") - принятая метафора для $C_0$.

10. __Centr__ ("центр", "разгар") - типовое обозначение "центральной" части
предмета или процесса.

11. $\mathbf{A_i}$ ($i = 1, \ldots, 4$) - типовое определение $i$-го
актанта по его реальной роли в ситуации
("такой, который...", "такой, которого..."):

12. $\mathbf{Able_i}$ (лат. habilis 'способный', "способный";
$i = 1, \ldots, 4$) - типовое определение $i$-го актанта по его
потенциальной роли в ситуации ("такой, который может...", "такой, которого
можно..."):

13. $\mathbf{Magn_0}$ и $\mathbf{Magn_i}$ (лат. magnus 'большой';
$i = 1, \ldots, 4$) - обозначение 'высокой степени', 'интенсивности'
($\approx$ 'очень') самой ситуации ($Magn_0$) или ее $i$-го актанта
($Magn_i$):

14. __Ver__ (лат. verus 'истинный') - 'правильный',
'соответствующий назначению', 'какой следует':

15. __Bon__ (лат. bonus 'хороший') - 'хороший':

16. $\mathbf{Adv_{ix}}$ $(i = 1, \ldots, 4; \; x = A, B, C, D)$ - имя
ситуации в роли определения при глаголе, называющем другую ситуацию.

17. __Loc__ (лат. locus 'место') - предлог типовой локализации
(пространст-50 венной, временной или абстрактной).
Под типовой локализацией понимается наиболее "прямое", наиболее
"естественное" расположение, т.е. расположение, наиболее соответствующее
природе и назначению "вещи", обозначенной ключевым словом - $C_0$.

18. $\mathbf{Oper_1}$, $\mathbf{Oper_2}$
(лат. operari 'совершать') - глагол, связывающий
название первого (соответственно второго) актанта в роли подлежащего с
названием ситуации в роли первого дополнения.

19. $\mathbf{Func_0}$, $\mathbf{Func_1}$, $\mathbf{Func_2}$ (лат. function
"исполнение") - глагол, имеющий название ситуации подлежащим, а названия
актантов, если они есть, - дополнениями.

20. $\mathbf{Labor_{12}}$ - глагол, связывающий название первого актанта
в роли
под- лежащего, с названием второго актанта в роли первого дополнения и с
названием ситуации в роли второго дополнения:

21. __Caus__ (лат. causa "причина") - "делать так, чтобы...", "каузировать".
Подлежащим при Caus (без актантных индексов) обязано быть название
неучастника ситуации.

22. __Perm__

23. __Liqu__

&nbsp;

___

&nbsp;

## __14. Модель Тузова В. А.  Адекватность и неадекватность модели. (WIP - completed, normalize length) (6222 chars) (Topic 3: pra7: 1. -> 17.; pra8: 18. -> 23.)__

&nbsp;

Абсолютно правильная лингвистическая интуиция И. А. Мельчука находилась в
явном противоречии с используемым им формальным аппаратом.
Для того, чтобы снять это противоречие, необходимо было прежде всего создать
адекватную математическую модель русского языка.

Теоретически для формализации любого реального объекта достаточны сколь
угодно скромные средства.
И это бесконечное разнообразие возможностей попождает сложнейшую проблему
выбора адекватных средств формализации.
Единственным доказательством адекватности той или иной модели

может служить лишь работающая компьютерная система.
Но построить такую систему можно только на основе адекватной модели.
Мы получаем тот самый замкнутый круг, в котором находится компьютерная
лингвистика с момента своего появления на свет.

Существуют неформальные признаки неадекватности используемой модели
реальному объекту.
Во-первых, неограниченное размножение сущностей, любую из которых быть
может и несложно поместить в формальноые сети, но каждая такая маленькая
победа создает лишь иллюзию возможности

окончательной победы.
Так происходит первая подмена - подмена реальной проблемы на множество
иллюзорных проблем.
Во-вторых, статичность используемых средств.
Почему-то считается, что такие типы данных, как семантические или нейронные
сети, фреймы, графы, множества сем и т.п.,

могут служить адекватным средством формализации предложений русского языка.
Однако каждое предложение динамично, оно является записью алгоритма и
поэтому не может быть представлено статичными типами данных.

Эти данные могут быть получены лишь в результате выполнения этого алгоритма.
Так происходит вторая важная подмена - живое предложение заменяется его
"скелетом".
В-третьих, неоднозначность смысла слова, предложения, текста.
Много было сказано и написано о неоднозначности естественного языка, о

том, что человек каким-то непостижимым образом выбирает тот самый правильный
смысл слова, который оно имеет в конкретном предложении Если предлагаемая
модель не позволяет ответить на вопрос о неоднозначности, что эта модель
не может быть адекватной русскому языку.

И здесь мы имеем дело с третьей подменой - проблема вычисления смысла
(точного значения) заменяется проблемой извлечения из текста хоть какой-то
инфомрации для решения конкретных практических задач.
Если предлагаемая модель не позволяет ответить на вопрос о неоднозначности,
то эта модель не может

быть адекватной русскому языку.
И здесь мы имеем дело с третьей подменой - проблема вычисления смысла
(точного значения) заменяется проблемой извлечения из текста хоть какой-то
информации для решения конкретных практических задач.
Подмена понятий - столь важная тема, что ей можно было бы посвятить
многотомный

труд. Подмена всегда приводит к путанице и бесконечным бесплодным
дискуссиям.
Например, вопрос, может ли компьютер понимать тексты на русском языке, до
сих пор способен вызвать бурную дискуссию.
Понимание человека и понимание компьютера - это принципиально разные
понятия.

Компьютер не способен понимать не только тексты на русском языке, но даже
тексты на языке Паскаль.
Он может и должен выполнять эти тексты.
Для того чтобы выполнить тексты на языке Паскаль, необходимо эти тексты
преобразовать в объектный код.
Чтобы выполнить тексты на русском языке,

Необходимо перевести их на формальный семантический язык.
Для этого необходим семантический словарь.
Семантический язык и построенный на его основе семантический словарь
русского языка составляют дальнейшее рассмотрение.
Поскольку компьютер не способен понимать тексты, а может их только

выполнять, то остается практически один способ формализации
языка - рассматривать предложение как запись последовательности
выполнимых действий.
Нравится нам это или нет, компьютер не оставляет нам другого выбора.
Вообще говоря, набор выполняемых действий зависит от

конкретной задачи и потому является потенциально неограниченным.
Так фраза _Сарай горит_ может быть преобразована в вызов функции
```Gorit1(Saraj)```, результатом выполнения которой при решении одной задачи
будет, например, изображение горящего сарая на экране, при решении другой -

заполнение базы знаний, при решении третьей - вызов пожарной команды, и т.д.
Во-первых, в рамках этой формализации можно построить записи только строго
ограниченного множества чисел, во-вторых, не существует единого алгоритма
даже для сложения двух чисел.
Арабская (индийская) система счисления

не ограничена каким-либо конечным множеством чисел и дает возможность
строить простые и универсальные алгоритмы для арифметических операций.
Римская система неадекватна, арабская - адекватна.
Поскольку принцип формализации, положенный в основание достаточно сложной
компьютерной

системы, имеет для нее фундаментальное значение, кажется уместным сказать
здесь несколько слов о методах формализации вообще.
Принято считать, что принципы формализации не формализуемы, из чего следует,
что при формализации той или иной предметной области всегда имеется
неограниченный выбор формальных

моделей.
Теоретически доказать, что одна модель лучше другой, невозможно.
И тем не менее из огромного множества моделей лишь одна (с точностью до
изоморфизма) может оказаться адекватной данной предметной области, и только
она может быть практически полезной для компьютеризации сложных предметных

областей.
Если бы русский язык содержал несколько сотен слов, то любая когда-либо
предлагавшаяся его модель могла бы быть реализована на компьютере и
оказалось бы практически полезной.
Но принципиальным свойством неадекватных моделей, как было сказано выше,
является безудержное размножение

сущностей при расширении или конкретизации предметной области (в данном
случае - при расширении словаря) и как следствие - отсутствие единых
алгоритмов обработки этих быстро размножающихся сущностей.
Здесь уместна аналогия с римской системой счисления - типичным примером

неадекватной формализации языка для записи натуральных чисел.
За свою сравнительно небольшую историю информатика продемонстрировала
огромное количество неадекватных моделей, тяжеловесность которых лишила
их возможности практического использования.

&nbsp;

___

&nbsp;

## __Тема 3. Вопрос 15. Функциональная природа языка. (около 492 символов) (pra8: 24-27)__

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

_Язык_ и _слово_ __триедины__: _слушаю - понимаю - говорю_.

Это __триединство__ отчетливо проявляется, например, в компьютерной
системе, предназначенной для перевода с одного языка на другой.

При анализе исходного текста __слово__ выступает в роли __функции__, в
результате выполнения которой строится формальный аналог
понятия - __набор семантических формул__.

Далее этот набор преобразуется в действующую функцию, в результате
выполнения которой строится текст на втором языке.

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

___

&nbsp;

## __16. Слово как понятие. (WIP - completed, normalize length) (4003 chars) (Topic 3: pra8: 28. -> 42.)__

&nbsp;

Слово является символом, за которым стоит понятие.
Понятие всегда связывается с некоторыми множеством, поэтому при его
описании главное - выделить то общее, что объединяет все элементы множества.
Возьмем, например, понятие _узел_.
Оно может указывать и на узелок, в котором

носят вещи, и на железнодорожный узел, и на узел связи, и на узел на
веревке, и на гордиев узел, и на женскую прическу.
Короче, оно может указывать на множество самых разнообразных объектов.
Общим, что их объединяет в одно понятие, является то, что все они подобны
узлу, который связывает две веревки.

Узел может связывать вещи, железные дороги, города, волосы, ребра графа,
детали машин,
все что угодно.
Поэтому _узел_ - это то, что связывает.
Эту информацию о слове _узел_ мы и должны передать компьютеру и ничего
более.
Кроме элементов подобия понятия может содержать в себе и близкие элементы
типа Как бы.

Поэтому и описание должно содержать элементы этого типа.
Без них трудно или невозможно описать даже простейшие понятия.
Рассмотрим, например, такие конкретные глаголы, как _кусать_ и _лягать_.
Их естественные толкования - подвергать кого-то действию своих зубов
(копыт) - могут вызвать сомнения в высказываниях

_Комары (мороз, кофта) кусают, Он лягнул его в своей статье_, поскольку
комары, а тем более мороз или кофта, не имеют зубов, а он не может иметь в
своей статье копыт.
Поэтому в этих описаниях допускаются элементы типа

Как бы - как бы зубов, как бы копыт.
В приведенных примерах все понятия различны.
Но при описании слов часто приходится решать проблему, следует ли.

различать понятия, на которые указывает то или иное слово.
С одним словом часто связывается несколько различных понятий.
Например, _изменять_ (_что_ или _кому_), _мешать_ (_что_ или _кому_),
_разбить_ (_сквер_ или _чашку_).
Все эти глаголы неоднозначны.

Поэтому их можно рассматривать как функции, т.е. их значение определяется
их аргументами.
Понятия различны, если они не имеют ничего общего, или это общее настолько
абстрактно, что практически не содержит никакой информации.

Так, главное значение глагола _гореть_ - подвергаться действию огня.
Сохраняет ли он это значение в высказываниях _Глаза (Уши, Руки) горят, Он
горит на работе, Он горит энтузиазмом (любовью), Он весь горит?_
Ответ зависит от конкретной задачи, которую решает компьютер.
Часто достаточно приписать глаголу _гореть_.

одно значение.
Глагол _гореть_ как бы однозначен.
Возьмем главное значение глагола _нарушать_ - делать так, что что-то не
соблюдается.
Трудно представить ситуацию, которая потребовала бы дифференциации в этом
слове различных понятий.
Глагол _нарушать_ однозначен.

Повторим один важный момент.

Слово является символом, за которым стоит понятие или предикат - формальный
аналог понятия.
Само по себе слово не является предикатом.
Оно лишь часть предложения, но и предложение не является предикатом, оно
является записью алгоритма, в качестве формального аналого которого здесь

предлагается использовать суперпозицию функций.
И только в результате выполенния этой суперпозиции строится множество
связанных между собой предикатов.
В теории формальных языков говорят не о выполнении, а о псевдовыполнении,
подчеркивая тот факт, что речь идет об отображении текста в

текст, например при трансляции текста на каком-либо языке программирования в
текст на языке ассемблера или объектный код.
И только в результате выполнения этого кода вычисляется окончательное
значение текста.
Речь идет о псевдовыполнении отдельного предложения.
Результатом псевдовыполнения является текст на

семантическом языке.
Процесс собственно выполнения этого текста может быть полностью определен
только классом решаемых задач их конкретной предметной области.
Поэтому не обсуждаем даже околоязыковые проблемы, такие, например, как
проблема связного текста.

Для решения этих проблем требуются совершенно другие основания, которые
лежат уже за пределами модели русского языка.

&nbsp;

___

&nbsp;

## __17. Слово как функция. (WIP - completed, normalize length) (5389 chars) (Topic 3: pra9: 43. -> 63.)__

&nbsp;

Семантический анализатор в процессе обработки исходного текста выполняет
два основных действия: выбор правильного значения (предиката - формального
аналога понятия) слова и построение из выбранных значений более сложного
предиката.

Это построение всегда носит характер функционального взаимодействия, в
результате которого вычисляется новое значение, в частности - новый
семантико-грамматический тип построенной конструкции.
Например, при взаимодействии предлога _В_ со словосочетанием _прошлом году_

вырабатывается тип Когда, со словом _лесу_ - тип Где, и т.п.
При взаимодействии прилагательного и существительного вырабатывается
грамматический тип существительного, однако семантика словосочетания может
существенно отличаться от семантики самого существительного.
(Например, в выражении

_белая ворона_.)
Это относится не только к прилагательным и существительным, но и к любому
слову, способному присоединять к себе другие слова.
Например, при взаимодействии предлога _В_ со словосочетанием _прошлом году_
вырабатывается тип Когда, со словом _лесу_ - тип Где, и т.п.
При взаимодействии

прилагательного и существительного вырабатывается грамматический тип
существительного, однако семантика словосочетания может существенно
отличаться от семантики самого существительного.
Часто используемое в лингвистике понятие _валентности_ следует понимать
буквально, в химическом смысле:

кислород и водород, реализуя свои валентности, перестают быть кислородом
и водородом, а создают новую сущность - воду.
С точки зрения информатики, присоединяемые слова являются аргументами, из
которых присоединяющее их слово строит новую конструкцию, семантика которой
может

существенно отличаться от семантики ее составляющих.
Любой достаточно развитый язык имеет функциональную природу, и только
суперпозиция функций адекватна структуре предложений такого языка.

Функциональная природа языка особенно ясно и просто проявляется при

вычислении семантико-грамматических типов предложных выражений, что
хорошо видно из примеров, построенных семантическим анализатором:

Поясним эти записи на примере выражения ```@Почему С(@Род горя$130023)```.
Предлог _С_ на классе ```$13``` существительных (класс существительных с
условным названием\
\
Психика)

в родительном падеже вырабатывает семантико-грамматический тип Почему.
Это происходит следующим образом.
После предварительной обработки описание слова _Горя_ будет представлено в
виде трех морфо-семантических альтернатив (чувство, подвергаться действию
огня и проявлять сильное желание):горя

```
ГОРЕ  {Сущ Сред Неодуш
$130023~@ОНО$702@Род} $130023(Z1:!Род)
ГОРЕТЬ{Глаг Деепр}
N%~ГОРЕНИЕ$12250(Z1: !Ото,Z2:
!Деепр,Z3: ОГОНЬ$1225~!Тв) ГОРЕТЬ
    {Глаг Деепр}
N%~ЖЕЛАНИЕ$1303(Z1: !Деепр,Z2:
!Тв)
```

Одна из альтернатив предлога _С_ (всего их - 49)
```
С {Предл $13~@Почему} (Z1:
ПСИХИКА$13~!Род)
```

может взаимодействовать с первой альтернативой слова _горя_ (совпадают
падеж и номер класса).
В результате взаимодействия этих альтернатив вычисляется значение типа
Почему.
Качество любого семантического анализатора можно оценивать по тому, как он
вычисляет семантико-грамматическое значение

предложно-падежных форм.
Но даже если он вычисляет эти значения с абсолютной точностью, то это не
гарантирует, что он способен справиться со всеми тонкостями семантического
анализа.
Подстановка падежной формы на место аргумента любого присоединяющего ее
слова требует иногда не менее скурпулезного вычисления.

Точность семантического анализа прямо зависит от качества и от полноты
семантического словаря.
Теперь у нас есть возможность точно сказать об области определения и
области значений

функций, каждая из которых связывается с тем или иным словом русского языка
на этапе семантического анализа.
Эти области совпадают и содержат значения вида ```<номер семантического класса>``` ```<@семантико-грамматический тип>```.

Например, ```$13~@Почему```.
Номер класса может отсутствовать.
Семантико-грамматический тип - это все вопросительные слова русского языка
(возможно, содержащие индекс: Какой01, КакА, КакВ и т.п.), сокращенные
названия падежей ```@Им```, ```@Вин``` и т.д. и слова, определяющие род и
число, ```он$702```,

```она$702```, ```оно$702```, ```они$702```.
(Здесь ```$702``` - номер класса местоимений, ```@``` - технический символ,
используемый семантическим анализатором.)
Каждое такое значение является идентификатором класса слов.
Например, ```$16~@Им``` - множество слов, принадлежащих классу
```$16 (ВРЕМЯ)``` существительных в

именительном падеже.
Если бы компьютер был способен выполнять эти функции так же, как он
выполняет арифметические операции, то семантический анализатор русского
языка в принципе ничем не отличался бы от обычного компилятора для языков
программирования.
Но так как он не способен выполнять эти функции

непосредственно, то семантический анализатор является интерпретатором
(в программистском смысле этого слова Процесс интерпретации разделен на
три этапа: морфологический анализ, пословная обработка текста и
собственно семантический анализ.
Если применить первые два этапа к множеству всех

словоформ русского языка, то можно построить словарь, благодаря которому
процесс интерпретации будет сведен к собственно семантическому анализу.
О процессе интерпретации будет сказано ниже.

&nbsp;

___

&nbsp;

## __18. Семантический словарь. Словарная статья такого словаря. (WIP - completed, normalize length) (2967 chars) (Topic 3: pra10: 64. -> 74.)__

&nbsp;

Построение семантического словаря - чрезвычайно сложная и трудоемкая
работа.
Выполнить такую работу в сравнительно короткие сроки удалось благодаря
удивительной регулярности словообразования в русском языке, которая
позволила автоматизировать процесс построения семантического словаря.

Оказалось возможным автоматически свести большое количество производных
слов к более простым по морфемному составу словам.
Так, например, при помощи суффикса _-тель_ образуется отглагольные
существительные, называющие первый аргумент глагола

(учить - учитель).
Число таких слов (в словаре А.А. Зализняка \[1\]) равно 692.
Из них 671 слово подпадает под это правило.
Исключением явдяется 21 слово: приятель, неприятель, числитель,
знаменатель и другие.
Поэтому описание семантики подавляющего большинства таких слов сводится к
описанию семантики

соответствующего глагола при помощи одной и той жей формулы.
Суффикс _-ость_ образует существительные от прилагательных, называющие
свойство объекта (дряхлый - дряхлость).
Всего таких слов 3177, исключение 53 слова: ревность, стоимость,
промышленность, решимость и другие.
Аналогичное явление наблюдается

при сведении префиксных глаголов к беспрефиксным.
При построении семантического словаря наиболее полезными оказались
словари: "Учебник русского языка для иностранцев",
"Управление в русском языке", "Словарь сочетаемости слов русского языка" и
"Большой толковый словарь русского языка".

Сейчас еще рано говорить о завершении работы над семантическим словарем.
Словарь находится в процессе постоянной модификации, но на его основе
построены семантический анализатор, способный анализировать
газетно-журнальные тексты, поисковая и вопросно-ответная системы, а также
система автоматического реферирования.

В процессе эксплуатации семантического словара выяснилось, что удобнее
разбить его на два рабочих словаря.
Один из них был назван синтаксическим, второй - семантическим.
При этом исходным словарем остается единый семантический словарь, который
можно легко модифицировать и совершенствовать,

а рабочие словари строятся по нему автоматически.
Сущность этого разбиения покажем на примере.
Исходный словарь:
```
ГОРЕТЬ
    N%~ГОРЕНИЕ$12250(Caus(ПРИЧИ
НА$1105(!Ото),Lab(!Им,ОГОНЬ$1225~!
Тв))) ГОРЕТЬ
N%~ЖЕЛАНИЕ$1303(Oper00(!Им,
```

```
Magn~ЖЕЛАНИЕ$1303(!Тв)))
```

Синтаксический словарь:

```
ГОРЕТЬ N%~ГОРЕНИЕ$12250({Z1:
!Ото,Z2: !Им,Z3:
ОГОНЬ$1225~!Тв})//001 ГОРЕТЬ
N%~ЖЕЛАНИЕ$1303({Z1: !Им,Z2:
!Тв})//002
```

Семантический словарь:

```
ГОРЕТЬ
N%~ГОРЕНИЕ$12250(Caus(ПРИЧ
ИНА$1105(Z1),Lab(Z2,Z3)))//001
ГОРЕТЬ
N%~ЖЕЛАНИЕ$1303(Oper00(Z1,
Magn~ЖЕЛАНИЕ$1303(Z2)))//002
```

Первый рабочий словарь содержит минимум информации, необходимый для
правильной сборки суперпозиции, и он не зависит от класса решаемых задач.
Второй словарь не влияет на процесс сборки и поэтому может быть достаточно
просто переориентирован на конкретный класс задач.

&nbsp;

___

&nbsp;

## __19. Предварительная обработка описания слова. (WIP - completed, normalize length) (1578 chars) (Topic 3: pra10: 84. -> 90.)__

&nbsp;

На этапе предварительной обработки происходит пословная обработка текста в
пределах одного предложения.
Основная задача этого этапа - построение независимых морфо-семантических
альтернатив в описаниях каждой словоформы предложения

и вычисление семантико-грамматического типа каждой альтернативы, входящей в
описание слова.
Эти преобразования необходимы для корректной работы собственно
семантического анализатора.

Например, предложение _Бумага идет в переработку_ в результате этих
преобразований примет вид

- Бумага
```
БУМАГА {Сущ Жен Неодуш
$12127~@ОНА$702@Им} $12127(Z1:
!Род,Z2: !ИЗ)
```
- идет
```
{Глаг} (Z1:
ЧЕЛОВЕК$1241~!ОНЪ$702\!ОНА$702\!О
НО$702,Z2: ДЕЙСТВИЕ$15~!Куда)
```

```
{Глаг} (Z1:
МЕСТО$121~!ОНЪ$702\!ОНА$702\!ОНО$7
02,Z2: ДЕЙСТВИЕ$15~!Куда)
(и т.д.)
```
- в
```
В {Предл $15~@Куда} (Z1:
ДЕЙСТВИЕ$15~!Вин) \ Всего - 109
альтернатив
```

- переработку
```
ПЕРЕРАБОТКА {Сущ Неодуш
$15131~@ОНА@Вин} $15131(s0~$15 Z1:
!Тв,Z2: !Род,Z3: !вВин)
```

После предварительной обработки описание каждого слова предложения
представляет собой набор одинаковых по форме альтернатив, каждая их которых

состоит из двух частей: морфологической и семантической.
Морфологическая часть (в фигурных скобках) содержит информацию о том, к чему
может присоединиться данная альтернатива;

семантическая часть - информацию о том, что эта альтернатива может к себе
присоединить.

Вся эта информация является необходимой и достаточной для выбора правильной
альтернативы и их правильного связывания при построении суперпозиции.

&nbsp;

___

&nbsp;

## __Тема 3. Вопрос 20. Сущность семантического анализа. (около 149 символов) (pra10: 91) (доступна лишь часть ответа)__

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

На этапе семантического анализа происходит отбор нужных для данного
предложения морфо-семантических альтернатив и связывание их в единую
структуру.

&nbsp;

__[Переместиться к Содержанию](#содержание)__

&nbsp;

___